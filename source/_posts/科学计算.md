---
title: 科学计算笔记
tags: 
  - Scientific Computation
categories: Math
keywords: Scientific Computing
description: 本文作为课程GCC5029数值计算方法(科学计算部分)的笔记整理。
cover: https://picture-1302512218.cos.ap-guangzhou.myqcloud.com/6-27/Pure-mathematics-formulæ-blackboard.jpg
date: 2019-01-06 21:57:12
katex: true
---

----

# 目录

``` Markdown
1. 目录
2. 模拟方法与误差
    2.1. 模拟方法
    2.2. 误差分析
        2.2.1. 向前误差和向后误差 Forward Error and Backward Error
        2.2.2. 敏感性与病态性 Sensitivity and Conditioning
        2.2.3. 条件数 Conditional Number
            2.2.3.1. 向量的条件数
            2.2.3.1. 方阵的条件数
            2.2.3.2. 误差限
        2.2.4. 截断误差和舍入误差 Truncation Error and Round-off Error
3. 线性方程组的求解
    3.1. 矩阵的秩
    3.2. 方程组解的个数
        3.2.1. 非奇异矩阵 Nonsingular Matrix
    3.3. 范数/模 Norm
        3.3.1. 向量的范数
            3.3.1.1. Euclidean Norm
            3.3.1.2. H-Norm
        3.3.2. 矩阵的范数
            3.3.2.1. p-范数诱导的矩阵范数
            3.3.2.2. Frobenius Norm
    3.4. 求解线性方程组的方法
    3.5. Gauss 消去法
        3.5.1. 初等消去矩阵
        3.5.2. Gauss 消去法内容
    3.6. 共轭梯度法 Conjugate Gradient Method
        3.6.1. 先置知识
        3.6.2. 矩阵A共轭向量
        3.6.3. 当已知某个矩阵A共轭向量集合时
        3.6.4. 共轭梯度法的收敛性
        3.6.5. 迭代系数alpha的设计
        3.6.6. 如何产生矩阵A共轭向量集合{p_i}
            3.6.6.1. Expanding Subspace Minimization
            3.6.6.2. 基于矩阵A共轭向量集合{p_i}特性产生{p_i}
        3.6.7. 共轭梯度法算法步骤
    3.7. 迭代法 Iterative Method (待更新)
        3.7.1. 雅可比迭代法 Jacobi Method (待更新)
        3.7.2. 高斯-塞德尔迭代法 Gauss-Seidel Method (待更新)
4. 线性最小二乘问题 (待更新)
5. 无约束优化
    5.1. 优化基础
    5.2. 下降方法的收敛性
        5.2.1. 关于收敛
        5.2.2. 部分下降方法的收敛性
    5.3. 最速下降法 Steepest Descent Method
    5.4. 牛顿法 Newton-Raphson Method
        5.4.1. 收敛性
    5.5. 实用牛顿法 Practical Newton Method
        5.5.1. 信赖域方法 Trust-Region Newton Methods
    5.6. 拟牛顿法 Quasi-Newton Method
        5.6.1. 拟牛顿条件/割线条件
        5.6.2. DFP方法
            5.6.2.1. DFP算法步骤
        5.6.3. BFGS方法
            5.6.3.1. BFGS算法步骤
6. 关于学习中的一些补充 (待更新)
```

# 模拟方法与误差

计算模拟重要方法：迭代法、逼近法

一般策略：

- 用有限维空间代替无限的空间。
- 用有限过程代替无限过程。
- 用代数方程代替微分方程。
- 用线性问题代替非线性问题。
- 用低阶方程组代替高阶方程组。
- 用简单函数代替复杂函数。
- 用简单结构的矩阵代替一般矩阵。

近似的来源：

- 建模：这个过程可能简化，或者和忽略问题或者系统的某些物理特性。
- 经验测量：实验设备精度所限。
- 前面的计算：输入的数据可能是中间数据，其结果只能是近似值。

## 误差分析

- 绝对误差 = 近似值 - 真值
- 相对误差 = 绝对误差 / 真值

总误差 = 计算误差 + 数据传播误差 ，比如

$$ \Delta f(x)=\hat f(\hat x)-f(x)=\underbrace{(\hat f(\hat x)-f(\hat x))}_{ComputationalError}+\underbrace{(f(\hat x)-f(x))}_{PropagatedDataError} $$

### 向前误差和向后误差

若有 $y=f(x)\quad and \quad\hat y=f(\hat x)$ ，则$\Delta y=\hat y-y$ 为向前误差；$\Delta x=\hat x-x$ 为向后误差。

![fig1.2](https://raw.githubusercontent.com/georgeokelly/hello-world/master/blog_images/2019_1_4/1-2.png)

$f(\hat x)=\hat f(x)$ 是因为$\hat x$的定义来自误差。

<div class="note info"><p>Note that the equality $\hat f(x)=f(\hat x)$ is due to the choice of $\hat x$; indeed, this requirement *defines* $\hat x$.</p></div>

### 敏感性和病态性 Sensitivity and Conditioning

在某些情况下，即便计算是完全精确的，问题的解对**数据的扰动**也可能是高度敏感的。

<div class="note info"><p>The qualitative notion of *insensitive*, and its quantitative measure, called *conditioning*, are concerned with propagated data error, i.e., the effects on the solution of perturbations in the input data.</p></div>

- 如果输入数据的相对变化对解的相对变化影响相对适中，则是**不敏感 (*insensitive*)** 的，或者**良态 (*well-conditioned*)** 的。
- 如果影响很大，则是**敏感 (*sensitive*)** 的，或者**病态 (*ill-conditioned*)** 的。

### 条件数

解的相对变化与输入数据的相对变化的比值称为条件数。(一个问题的条件数远远大于1，则是病态的。)

$$ Condition\quad number=\frac{|(f(\hat x)-f(x))/f(x)|}{|(\hat x-x)/x|}=\frac{|\frac{\hat y-y}{y}|}{|\frac{\hat x-x}{x}|}=|\frac{\Delta y/y}{\Delta x/x}|$$

$$\underbrace{|\Delta y/y|}_{Relative\quad Forward\quad Error} = Condition\quad number \times \underbrace{|\Delta x/x|}_{Relative\quad Backward\quad Error}$$

<div class="note success"><p>取$\hat f(x)-f(x)=f(\hat x)-f(x)\simeq f'(x)\Delta x$，有条件数≈$|\frac{xf'(x)}{f(x)}|$</p></div>

#### 向量的条件数

$$\vec x=(x_1,x_2,\cdots,x_n)^T,\qquad \vec y=\boldsymbol{F}(\vec x)=(f_1(\vec x),f_2(\vec x),\cdots,f_n(\vec x))^T$$

$$\Delta y_i=\sum_{j=1}^n\frac{\partial f_i(\vec x)}{\partial x_j}\Delta x_j$$

由于

$$\epsilon_{y_i}=\frac{\Delta y_i}{f_i(\vec x)},\quad \epsilon_{x_j}=\frac{\Delta x_j}{x_j}$$

所以

$$\epsilon_{y_i}=\frac{1}{f_i(\vec x)}\sum_{j=1}^n\frac{\partial f_i(\vec x)}{\partial x_j}x_j \epsilon_{x_j}$$

即条件数

$$Condition\quad number=\left(
\begin{array}{ccc}
\frac{x_1}{f_1(\vec x)}\frac{\partial f_1(\vec x)}{\partial x_1} & \frac{x_2}{f_1(\vec x)}\frac{\partial f_1(\vec x)}{\partial x_2} & \cdots\\
\frac{x_1}{f_2(\vec x)}\frac{\partial f_2(\vec x)}{\partial x_1} & \frac{x_2}{f_2(\vec x)}\frac{\partial f_2(\vec x)}{\partial x_2} & \cdots\\
\vdots & \vdots & \ddots
\end{array} \right)$$

#### 方阵的条件数

非奇异矩阵的条件数定义为$cond(\mathbf A)=\|\mathbf A\|\cdot \|\mathbf A^{-1}\|$

<div class="note success">***Proof:***
<p>在有误差的情况下，有$\mathbf A(\vec x+\delta\vec x)=\vec b+\delta \vec b$。</p>
<p>因此$\|\delta \vec x\|=\|\mathbf A^{-1}\delta \vec b\|\leq \|\mathbf A^{-1}\|\|\delta \vec b\|$.</p>
<p>又$\|\vec b\|=\|\mathbf A\vec x\|\leq\|A\|\cdot\|x\|\Rightarrow \frac{1}{\|\vec x\|}\leq \frac{\|\mathbf A\|}{\|\vec b\|}$.</p>
<p>两式相乘，得到$\frac{\delta \vec x}{\|\vec x\|}\leq\|A\|\|A^{-1}\| \frac{\|\delta \vec b\|}{\|\vec b\|}$.</p>
故条件数为$cond(\mathbf A)=\|\mathbf A\|\cdot \|\mathbf A^{-1}\|$。</div>

#### 误差限

方程组解的相对变化，可用条件数乘以问题中数据的相对变化来界定。
$\frac{\delta \vec x}{\|\vec x\|}\leq cond(A) \cdot(\frac{\|\Delta \mathbf A\|}{\|\mathbf A\|}+ \frac{\|\delta \vec b\|}{\|\vec b\|})$

<div class="note success">***Proof:*** <p>取$\mathbf A(t)=\mathbf A+t\Delta\mathbf A,\quad\vec b(t)=\vec b+t\delta\vec b$, 并考虑线性方程组$\mathbf A(t)\vec x(t)=\vec b(t)$ 的解 $\vec x(t)=\vec x+t\delta\vec x$。求导并使$t\to 0$后取范数并整理即得该不等式。</p></div>

### 截断误差和舍入误差

计算误差（计算过程产生的误差）可以分为截断误差（级数的截断，迭代的中止）和舍入误差（有限精度）。

# 线性方程组的求解

$\mathbf A\vec x=\vec b\quad \mathbf A \in \mathbb R^{m\times n}, \vec b\in \mathbb R^{m}$

## 矩阵的秩

矩阵的 **秩**

- 是矩阵列向量生成的向量空间的维数 (Bourbaki, *Algebra*)
- 是极大线性无关组的元素向量个数
- 是矩阵作为线性映射变换矩阵生成的像的维度

矩阵的列秩和行秩总是相等的，因此它们可以简单地称作矩阵的秩。

## 方程组解的个数

### 非奇异矩阵

对于方阵A，若满足下列等价条件之一则为非奇异；否则为奇异。

- A的逆矩阵存在
- 行列式$det(\mathbf A)\neq 0$
- n阶矩阵的秩$Rank(\mathbf A)=n$
- 对任何非零向量 $\vec z\neq 0,\mathbf A\vec z\neq 0$

所以

1. 若矩阵A非奇异，无论b取何值，方程组 **总有唯一解**
2. 若矩阵A奇异，则解的个数由b取值决定，可能无解，也可能由无数解，且必存在非零向量z使得$\mathbf A\vec z=0$。

有解的**充要条件**： $Rank(\mathbf A)=Rank[\mathbf A,\vec b]$

## 范数/模 Norm

Norm是具有“长度”概念的函数。在线性代数、泛函分析及相关的数学领域，是一个函数，其为向量空间内的所有向量赋予非零的正长度或大小，满足

1. 半正定性；$norm(v)\geq 0$
2. 齐次性；$norm(av)=|a|\cdot norm(v)$
3. 三角不等式成立；$norm(v_1)+norm(v_2)\geq norm(v_1+v_2)$
4. **正定性（不满足则为半范数）**；$norm(v)= 0\quad iff\quad \vec v=\vec 0$

如果拓扑向量空间的拓扑可以被范数导出，这个拓扑向量空间被称为赋范向量空间.

### 向量的范数

#### Euclidean-norm

$$l_1-norm:\quad \|\vec x\|_1=\sum_{i=1}^n |x_i|.$$

$$l_2-norm:\quad \|\vec x\|_2=(\sum_{i=1}^n |x_i|^2)^\frac{1}{2}=\sqrt{x^Tx}.$$

$$l_\infty-norm:\quad \|\vec x\|_\infty=\max_{1\leq i\leq n} |x_i|.$$

$$l_p-norm:\quad \|\vec x\|_p=(\sum_{i=1}^n |x_i|^p)^\frac{1}{p}.$$

#### H-norm

matrix H is positive definite. $\mathbf H\geq 0$

$$H-norm:\quad \|x\|_H=\sqrt {x^T\cdot H\cdot x}.$$

### 矩阵的范数

#### p-范数诱导的矩阵范数

$$\|\mathbf A\|=\max_{\vec x\neq\vec 0}\frac{\|\mathbf A\vec x\|}{\|\vec x\|}$$

$$1-norm:\quad \|\mathbf A\|_1=\max_{j}\sum_{i=1}^m|a_{ij}|.$$

$$\infty-norm:\quad \|\mathbf A\|_\infty=\max_{i}\sum_{j=1}^m|a_{ij}|.$$

#### Frobenius norm

Frobenius 范数定义为

$$Frobenius-norm:\quad \|\mathbf A\|_F= (\sum_{i=1}^m\sum_{j=1}^n a_{ij}^2)^{1/2}.$$

已知实对称矩阵有完备的特征向量系，即有$AV=V\Lambda$，其中$V$为正交阵，$\Lambda$为对角阵。

## 求解线性方程组的方法

线性方程组左乘一个非奇异矩阵，方程组的解不变。

1. 排列矩阵 Permutation Matrix
2. 对角线调整 Postive Definite Diagonal Matrix

- 下三角线性方程组 $\mathbf L\vec x=\vec b$
- 上三角线性方程组 $\mathbf U\vec x=\vec b$

## Gauss 消去法

### 初等消去矩阵

$$M_k\alpha=
\left(
\begin{array}{ccc}
1 \\
  & \ddots \\
  &  &  1\\
  &  &  -m_{k+1} & 1\\
  &  &  \vdots   &  &  \ddots\\
  &  &  -m_n     &  &  &  1
\end{array}\right)
\left(
\begin{array}{ccc}
\alpha_1\\
\vdots\\
\alpha_k\\
\alpha_{k+1}\\
\vdots\\
\alpha_n\\
\end{array}\right)=
\left(
\begin{array}{ccc}
\alpha_1\\
\vdots\\
\alpha_k\\
0\\
\vdots\\
0\\
\end{array}\right)
$$
$M_k$是一个单位下三角矩阵，必定非奇异。

$$M_k=I-m_ke_k^T=I-
\left(\begin{array}{ccc}
0\\
\vdots\\
0\\
0\\
m_{k+1}\\
\vdots\\
m_n
\end{array}\right)
\left(\begin{array}{ccc}
0,\cdots,0,1_k,0,\cdots,0
\end{array}\right)
$$

因为$e_k^Tm_k=0$，所以$M_K^{-1}=I+m_ke_k^T$。如果j>k,由于$e_k^Tm_j=0$，所以
$$M_kM_j=[I-m_ke_k^T][I-m_je_j^T]=I-m_ke_k^T-m_je_j^T+m_k(e_k^Tm_j)e_j^T=I-m_ke_k^T-m_je_j^T$$

### Gauss消去法内容

<div class="note warning">**对应问题：** 求解$Ax=b$</div>

$$M\cdot Ax=M_{n-1}\cdots M_2M_1Ax=Ux$$

$$M\cdot b=M_{n-1}\cdots M_2M_1b$$

高斯消去法即选主元（有限精度必须，避免误差放大），再将A转换成上/下三角矩阵后求解。

## 共轭梯度法 Conjugate Gradient Method

<div class="note warning">**对应问题：** 求解$Ax=b$, where A is an nxn matrix, symmetric and positive definite (A^T=A, A>0).</div>

该问题可以等价于求函数f(x)的极值： $f(x)=\frac{1}{2}x^TAx-b^Tx$。这里记残量(residual)函数$r(x):=\nabla f(x)=Ax-b$

### 先置知识

需要了解迭代、搜索方向等内容，此处不赘述。

### 矩阵A共轭向量

如果非零向量集合$\{p_0,p_1,\cdots,p_l\}$  满足  $p_i^TAp_j=0\quad for\quad all\quad i\neq j$，则称该集合对实对称正定矩阵A共轭。易证$p_i$线性无关。

<div class="note success">***Proof:*** <p>对于$a_0p_0+a_1p_1+\cdots+a_lp_l=0$，左乘$p_0^T$得$p_0^Ta_0p_0+\underbrace{\cdots}_{=0}=0$。又因为$p_0^Ta_0p_0=a_0(p_0^Tp_0)\quad and\quad (p_0^Tp_0)\neq 0$ 所以 $a_0=0$。同理可得$\forall a_i=0$，故得证。</p></div>

### 当已知某个矩阵A共轭向量集合时

用共轭向量$p_k$作为k-th迭代时的方向。即$x_{k+1}=x_k+\alpha_kp_k$，其中$\alpha_k(:=-\frac{r_k^Tp_k}{p_k^TAp_k})$是一维的步长系数，即标量。

### 共轭梯度法的收敛性

共轭梯度算法可在最多n次迭代内收敛到问题的目标解。

<div class="note info">For any $x_0 \in R^n$, the sequence {$x_k$} generated by the conjugate direction algorithm converges to the solution $x^*$ of the linear system in **at most n steps**.</div>

<div class="note success">***Proof:*** <p>当迭代n次时，因为{$p_i$}线性无关，可以作为n维空间的基，张成空间内的任意向量，包括目标解$x^*$。故若选取合适的$\alpha_i$满足$x_k-x^*=(x_0+\sum_{i=1}^{k-1}\alpha_ip_i)-(\sum_{i=0}^{n-1}\delta_i^*p_i)=0$，最多n次迭代即可得到目标解。</p></div>

### 迭代系数alpha的设计

已知存在表达式$x^*-x_0=\sum_{i=0}^{n-1}\delta_ip_i$，左乘$p_k^TA$可得

$$
p_k^TA(x^*-x_0)=p_k^TA\sum_{i=0}^{n-1}\delta_ip_i=p_k^TA\delta_kp_k\\
p_k^TA(x^*-x_0)=p_k^TA(x^*-x_k+x_k-x_0)=p_k^TA(x^*-x_k)+0=p_k^T(b-Ax_k)=-p_k^Tr_k\\
Let\quad \alpha_k=\delta_k=\frac{-r_k^Tp_k}{p_k^TAp_k}
$$

### 如何产生矩阵A共轭向量集合{p_i}

#### Expanding Subspace Minimization

$x_0\in \mathbb{R}^n$ 且 $\{x_i\}_{i=1}^k$ 由 A-共轭向量生成。则有：

part (1)

$$r_k^Tp_i=0,\quad for\quad i=0, 1,\dots,k-1$$ 

part (2)

对于$\{x|x=x_0+span(p_0,p_1,\dots,p_{k-1})\}$，$x_k$是问题$f(x)=\frac{1}{2}x^TAx-b^Tx$ 的最小值点。

<div class="note success">***Proof:***
<p>(1)显然的，有以下几个式子成立</p>

$$r_1^Tp_0=(r_0+\alpha_0 Ap_0)^Tp_0=r_0^Tp_0-r_0^Tp_0=0$$

$$r_k^Tp_{k-1}=(r_{k-1}+\alpha_{k-1} Ap_{k-1})^Tp_{k-1}=0$$

$$
r_k^Tp_i=(r_{k-1}+\alpha_{k-1} Ap_{k-1})^Tp_i\\
=r_{k-1}^Tp_i-\alpha_{k-1} p_{k-1}^TAp_i\\
=r_{k-1}^Tp_i+0\\
for\quad i=0,1,\dots,k-2$$

最后一个式子说明$r_k^Tp_i$最终都可以转换成$r_{i+1}^Tp_i=0$，故(1)得证。

(2)令$h(\sigma)=f(x_0+\sigma_0p_0+\dots+\sigma_{k-1}p_{k-1})$，对于目标解$\sigma^*$有：

$$\frac{\partial h(\sigma^*)}{\partial\sigma_i}=0=\frac{\partial h(\sigma^*)}{\partial(\sigma_ip_i)}\frac{\partial(\sigma_ip_i)}{\partial\sigma_i}\\
=\frac{\partial f(x_0+\sigma_0p_0+\dots+\sigma_{k-1}p_{k-1})}{\partial(\sigma_ip_i)}p_i\\
=\nabla f(x^*)^Tp_i=(Ax^*-b)^Tp_i\\
=r(x^*)^Tp_i\\
for\quad i=0,1,\dots,k-1$$

同时有$r_k=r(x_k)=Ax_k-b$ 和 $r_k^Tp_i=0$，即$r(x_k)^Tp_i=r(x^*)^Tp_i=0$.

故$x_k$满足解$x^*$的条件，(2)得证。</div>

#### 基于矩阵A共轭向量集合{p_i}的特性产生{p_i}

由于$\{p_i\}_{i=0}^k$的关于矩阵A共轭特性，$p_k$可以仅由$p_{k-1}$ “正交”产生，而必然满足与前面生成的$\{p_i\}_{i=0}^{k-2}$ 关于矩阵A共轭。

取$p_k=-r_k+\beta_k p_{k-1}$，将其左乘$p_{k-1}^TA$ 可得

$$\beta_k=\frac{p_{k-1}^TAr_k}{p_{k-1}^TAp_{k-1}}$$

因此有以下性质：

part (1)

$$r_k^Tr_i=0\quad for\quad i=0,\dots,k-1$$

part (2)

$$span(p_0,\dots,p_k)=span(r_0,\dots,r_k)=span(r_0,Ar_0,\dots,A^kr_0)$$

<div class="note success">***Proof:***

<p>首先$r_k=\beta_kp_{k-1}-p_k$ 所以仅有i=k-1时需要证明其不为0。</p>
$$r_k^Tr_{k-1}=\beta_kp_{k-1}^Tr_{k-1}=\frac{p_{k-1}^TA(r_kp_{k-1}^T)r_{k-1}}{p_{k-1}^TAp_{k-1}}=0$$

(1)得证。

用数学归纳法易证(2)。假设$r_k\in span(r_0,Ar_0,\dots,A^kr_0)$ 然后推广到$r_{k+1}$ 即可证明$span(r_0,\dots,r_k)\in span(r_0,Ar_0,\dots,A^kr_0)$。反过来也很容易证明。</div>


### 共轭梯度法算法步骤

<div class="note primary no-icon">CG-Preliminary Version

- Set $r_0:=Ax_0-b,\quad p_0:=-r_0,\quad k:=0$
- while $r_k\geq tolerance$ :
  1. $\alpha_k:=-\frac{r_k^Tp_k}{p_k^TAp_k}$
  2. $x_{k+1}:=x_k+\alpha_kp_k$
  3. $r_{k+1}:=Ax_{k+1}-b$
  4. $\beta_{k+1}:=\frac{r_{k+1}^TAp_k}{p_k^TAp_k}$
  5. $p_{k+1}:=-r_{k+1}+\beta_{k+1}p_k$
  6. $k++$
- end</div>

<div class="note primary no-icon">CG-Pratical Version

- Set $r_0:=Ax_0-b,\quad p_0:=-r_0,\quad k:=0$
- while $r_k\geq tolerance$ :
  1. $\alpha_k:=-\frac{r_k^Tr_k}{p_k^TAp_k}(=-\frac{r_k^Tp_k}{p_k^TAp_k})$
  2. $x_{k+1}:=x_k+\alpha_kp_k$
  3. $r_{k+1}:=r_k+\alpha_kAp_k$
  4. $\beta_{k+1}:=\frac{r_{k+1}^Tr_{k+1}}{r_k^Tr_k}$
  5. $p_{k+1}:=-r_{k+1}+\beta_{k+1}p_k$
  6. $k++$
- end</div>

易证两者是等价的。

## 迭代法

<div class="note warning"><p>**对应问题：** 求解$Ax=b.$ A为非奇异矩阵。</p>
当A为低阶稠密矩阵时，高斯消去法可以有效求解。但对于大型稀疏矩阵（A阶数很大，且零元素较多，比如n>10^4），这时利用迭代法求解时合适的。在计算机内存和运算两方面，迭代法都可以利用大量零元素的特点。</div>

### 雅可比迭代法

待更新

### 高斯-塞德尔迭代法

待更新

# 线性最小二乘问题

待更新

# 无约束优化

## 优化基础

1. 泰勒展开
2. 一阶必要条件：
  如果x^star 是f(x)局部最小值，并且函数f(x)在x^star 的邻域内连续可微，那么$\nabla f(x^*)=0$, 即x^star 为驻点

<div class="note success">***Proof:*** 用反证法，利用泰勒公式构造式子，证明与局部最小矛盾。</div>

3. 二阶必要条件：
  如果x^star 是f(x)局部最小值，并且函数$\nabla^2f(x)$在x^star 的邻域内连续，那么$\nabla f(x^*)=0\quad and\quad \nabla^2f(x^*)$ 是半正定的

<div class="note success">***Proof:*** 同理，用反证法，利用泰勒公式构造式子，证明与局部最小矛盾。</div>

4. 二阶充分条件：
  如果函数$\nabla^2f(x)$在x^star的邻域内连续，并且$\nabla f(x^*)=0\quad and\quad \nabla^2f(x^*)$ 是正定的，那么x^star是函数的严格局部最小

<div class="note success">***Proof:*** 取半径r>0构造球形域，此时Hessian矩阵$\nabla^2f(x)$对球形域内任意x而言都是正定的。对于任意范数$\|p\|$小于r的向量，有

$$f(x^*+p)=f(x^*)+p^T\nabla f(x^*)+\frac{1}{2}p^T\nabla f(x^*+tp)p\\
=f(x^*)+\frac{1}{2}p^T\nabla f(x^*+tp)p$$。

而因为Hessian矩阵正定，有$p^T\nabla f(x^*+tp)p>0$，故局部最小得证。</div>

5. (A). 如果函数convex，那么任意局部最小x^star就是全局最小；(B). 如果函数可微，那么任意驻点x^star是全局最小

<div class="note success">***Proof:*** 利用Convexity property 和 Jensen's inequality进行构造式子可证(A)；用反证法，假设$x^*$是驻点但不是全局最小。首先$\lim_{\lambda\to 0}\frac{f(x^*+\lambda(z-x^*))-f(x^*)}{\lambda}=\nabla f(x^*)^T(z-x^*)$。

利用Jensen's inequality得

$$\lim_{\lambda\to 0}\frac{f(x^*+\lambda(z-x^*))-f(x^*)}{\lambda}\leq\lim_{\lambda\to 0}\frac{\lambda f(z)+(1-\lambda)f(x^*)-f(x^*)}{\lambda}\\=f(z)-f(x^*)<0$$，得到$\nabla f(x^*)^T<0$即$x^*$不是驻点，与假设矛盾，故(B)得证。</div>

## 下降方法的收敛性

### 关于收敛

线性收敛 Linear Convergence

$$\|x_{k+1}-x^*\|\leq c\|x_k-x^*\|\quad 0<c<1$$

二次收敛 Quadratic Convergence

$$\|x_{k+1}-x^*\|\leq c\|x_k-x^*\|^2\quad 0<c<1$$

超线性收敛 Superlinear Convergence

$$\lim_{k\to 0}\frac{\|x_{k+1}-x^*\|}{\|x_k-x^*\|}=0$$

### 部分下降方法的收敛性

Method|Complexity|Convergence
:--:|:--:|:--:
Steepest Descent|O(n)|Linear
Conjugate Gradient|O(n)|Linearfail
Newton's|O(n^3)|Quadratic
Damped Newton's|O(n^3)|Superlinear
Quasi-Newton (DFP)|O(n^2)|Superlinear
Quasi-Newton (BFGS)|O(n^2)|Superlinear

## 最速下降法 Steepest Descent Method

<div class="note info">此处内容可参考 ***Convex Optimization***, *Stephen Boyd (page475)*</div>

最速下降法比较简单，只需搜索方向设置为最速下降方向（假设读者知道优化中的搜索相关内容）。对于$f(x+v)\simeq f(x)+\nabla f(x)^Tv$，一个规范化的最速下降方向满足（可能有多个最优解）：
$$
\Delta x_{nsd}=argmin\{\nabla f(x)^Tv\Big|\|v\|=1\}
$$
当v的方向为梯度方向时，即是梯度下降法。而相比而言，最速下降可以选取非Euclidean norm，或者多个最优解中的其中一个。

Reference: [最速下降法与梯度下降法区别](https://blog.csdn.net/daodaipsrensheng/article/details/81408212)

## 牛顿法 Newton-Raphson Method

<div class="note warning"><p>**对应问题：** 求解$g(x)=0.$ 以及可以转化成该形式的问题。</p></div>

<div class="note info">此处内容同计算统计 ***Computational Statistics***, *Guo-Liang TIAN, 2018 (page33-37)*</div>

设$x_t$是其根$x^*$的近似。利用中值定理，有：
$$
g(x_t)-0=g(x_t)-g(x^*)=g'(x_\alpha)(x_t-x^*)\\
x_\alpha \in \big[min\{x_t, x^*\}, max\{x_t, x^*\}\big]
$$
用$x_t$替代$x_\alpha$，并用$x_{t+1}$替代$x^*$，则有：
$$
x_{t+1}=x_t-\frac{g(x_t)}{g'(x_t)}
$$
### 收敛性

$$Let\quad F(x)=x-\frac{g(x)}{g'(x)}$$
$$
F'(x^*)=F'(x)|_{x=x^*}=1-\frac{g'(x)^2-g(x)g''(x)}{g'(x)^2}\bigg|_{x=x^*}\\
=\frac{g(x)g''(x)}{g'(x)^2}\bigg|_{x=x^*}=\frac{g(x^*)g''(x^*)}{g'(x^*)^2}\\
=0\qquad \because g(x^*)=0
$$
**收敛率** $c=\lim_{t\to\infty} \frac{\|x_t-x^*\|}{\|x_t-x^*\|^2}=\frac{1}{2}|f''(\hat x)|$，所以是二次收敛的。

## 实用牛顿法 Practical Newton's Method

<div class="note info">该部分内容可以参考 ***Numerical Optimization***, *1999, Nocedal J., Wright S.J. (page134-162)*</div>

包括

- Inexact Newton Steps
- Line Search Newton Methods
- Hessian Modifications
- Trust-Region Newton Methods

### 信赖域方法 Trust-Region Newton Methods

用对称矩阵$B_k=\nabla^2 f(x_k)$ 计算优化步 step：
$$
p_k=argmin\{m_k(p)=f(x_k)+f(x_k)^Tp+\frac{1}{2}p^TB_kp\}\\
s.t.\quad \|p\|\leq\Delta_k
$$
根据比例$\rho_k=\frac{f(x_k)-f(x_k+p_k)}{m_k(0)-m_k(p_k)}$调整信赖域$\Delta_k$ 或赋值$x_{k+1}=x_k+p_k.$

其中有个the dogleg method：狗腿法，名字比较有趣 :)

Reference: [数值优化 Ch.4 信赖域方法](https://www.cnblogs.com/HanDoMind/p/9440532.html)

## 拟牛顿法 Quasi-Newton Method

<div class="note warning"><p>**对应问题：** 求解$g(x)=0.$ 以及可以转化成该形式的问题。</p>
牛顿法虽然收敛速度快，但每次迭代都要计算Hessian矩阵，极大地复杂了计算度。所以类似Fisher Scoring算法对Newton-Raphson算法的改进，拟牛顿法构造出可以近似Hessian矩阵的正定对称阵，在“拟牛顿”的条件下优化目标函数。</div>

### 拟牛顿条件/割线条件

下文B表示对Hessian矩阵的近似，D表示Hessian矩阵的逆矩阵的近似。即 $B\simeq H, D\simeq H^{-1}$

k+1次迭代后进行泰勒展开有：
$$
\nabla f(x)\simeq\nabla f(x_{k+1})+H_{k+1}\cdot (x-x_{k+1})
$$
取$x=x_k$，并记$s_k=x_{k+1}-x_k, y_k=\nabla f(x_{k+1})-\nabla f(x_k)$，则有：

$$y_k\simeq H_{k+1}\cdot s_k$$

或

$$s_k\simeq H_{k+1}^{-1}\cdot y_k$$

这就是拟牛顿条件，它对迭代过程中的Hessian矩阵作约束。故近H似矩阵B和逆矩阵近似矩阵D满足：

$$y_k\simeq B_{k+1}\cdot s_k$$

或

$$s_k\simeq D_{k+1}^{-1}\cdot y_k$$

### DFP方法

DFP核心在于：用$D_k$来近似$H_{k}^{-1}$，若有：

$$D_{k+1}=D_k+\Delta D_k,\quad k=0,1,2,\cdots$$

为保持D的对称性，假设有：

$$\Delta D_k=\alpha uu^T+\beta vv^T$$

将其代入有
$$
s_k=D_ky_k+\alpha uu^Ty_k+\beta vv^Ty_k\\
=D_ky_k+u(\alpha u^Ty_k)+v(\beta v^Ty_k)\\
=D_ky_k+(\alpha u^Ty_k)u+(\beta v^Ty_k)v
$$
不妨令$\alpha u^Ty_k=1,\quad\beta v^Ty_k=-1$，有

$$u-v=s_k-D_ky_k$$

不妨令$u=s_k,\quad v=D_ky_k$，有
$$
\alpha=\frac{1}{s_k^Ty_k},\quad\beta=-\frac{1}{(D_ky_k)^Ty_k}=\frac{-1}{y_k^TD_k^Ty_k}=\frac{-1}{y_k^TD_ky_k}
$$
这样就构造出了一个校正矩阵$\Delta D_k=\frac{s_ks_k^T}{s_k^Ty_k}-\frac{D_ky_ky_k^TD_k}{y_k^T D_k y_k}$

#### DFP算法步骤

<div class="note primary no-icon">DFP

We have: $D_k\simeq H_k^{-1}, g_k=\nabla f(x_k)$

- Set x_0, tolerance and $D_0:=I,\quad k:=0$
- while $g_k\geq tolerance$ :
  1. $d_k:=-D_k\cdot g_k$
  2. $\lambda_k:=argmin\{f(x_k+\lambda d_k)\}$
  3. $s_k:=\lambda_kd_k$
  4. $x_{k+1}:=x_k+s_k$
  5. $y_k:=g_{k+1}-g_k$
  6. $D_{k+1}:=D_k+\frac{s_ks_k^T}{s_k^Ty_k}-\frac{D_ky_ky_k^TD_k}{y_k^T D_k y_k}$
  7. $k++$
- end</div>

### BFGS方法

BFGS核心在于直接逼近近似$H_{k}$，若有：

$$B_{k+1}=B_k+\Delta B_k,\quad k=0,1,2,\cdots$$

同样，为保持B的对称性，假设有：

$$\Delta B_k=\alpha uu^T+\beta vv^T$$

将其代入有
$$
y_k=B_ks_k+(\alpha u^Ts_k)u+(\beta v^Ts_k)v
$$
不妨令$\alpha u^Ts_k=1,\quad\beta v^Ts_k=-1$ 以及 $u=y_k,\quad v=B_ks_k$，有
$$
\alpha=\frac{1}{y_k^Ts_k},\quad\beta=\frac{-1}{s_k^TB_ks_k}
$$

这样就构造出了一个校正矩阵$\Delta B_k=\frac{y_ky_k^T}{y_k^Ts_k}-\frac{B_ks_ks_k^TB_k}{s_k^T B_k s_k}$

#### BFGS算法步骤

<div class="note primary no-icon">DFP

We have: $B_k\simeq H_k, g_k=\nabla f(x_k)$

- Set x_0, tolerance and $B_0:=I,\quad k:=0$
- while $g_k\geq tolerance$ :
  1. $d_k:=-B_k^{-1}\cdot g_k$
  2. $\lambda_k:=argmin\{f(x_k+\lambda d_k)\}$
  3. $s_k:=\lambda_kd_k$
  4. $x_{k+1}:=x_k+s_k$
  5. $y_k:=g_{k+1}-g_k$
  6. $B_{k+1}:=B_k+\frac{y_ky_k^T}{y_k^Ts_k}-\frac{B_ks_ks_k^TB_k}{s_k^T B_k s_k}$
  7. $k++$
- end</div>

# 关于学习中的一些补充

## 正定

待更

<!-- Last SVG -->
![](https://img.shields.io/badge/last--updated-2019.1.28-blue.svg)